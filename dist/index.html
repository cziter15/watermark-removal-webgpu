<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ks-unwatermarker</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/ort.all.min.js"></script>
    <style>
        :root {
            --primary-color: #6366f1;
            --secondary-color: #8b5cf6;
            --background-color: #0f172a;
            --surface-color: #1e293b;
            --card-color: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --accent-color: #4ade80;
            --error-color: #f87171;
            --warning-color: #fbbf24;
            --info-color: #60a5fa;
        }
        *{margin:0;padding:0;box-sizing:border-box}
        body{
            font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
            background:var(--background-color);color:var(--text-primary);min-height:100vh;
            display:flex;flex-direction:column;justify-content:center;align-items:center;
            padding:20px;line-height:1.6
        }
        .container{
            background:var(--surface-color);border-radius:20px;
            box-shadow:0 20px 60px rgba(0,0,0,.5);padding:30px;max-width:1200px;width:100%;
            border:1px solid rgba(255,255,255,.1);margin-bottom:20px
        }
        h1{margin-bottom:10px;font-size:28px;text-align:center}
        .subtitle{margin-bottom:30px;font-size:16px;text-align:center;color:var(--text-secondary)}
        .loading-screen{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:60px 20px;text-align:center}
        .loading-icon{font-size:64px;margin-bottom:20px;animation:pulse 2s infinite}
        @keyframes pulse{0%{transform:scale(1);opacity:.8}50%{transform:scale(1.1);opacity:1}100%{transform:scale(1);opacity:.8}}
        .loading-text{font-size:20px;margin-bottom:10px}
        .loading-subtext{color:var(--text-secondary);font-size:14px}
        .loading-bar{width:100%;height:6px;background:rgba(255,255,255,.1);border-radius:3px;margin-top:30px;overflow:hidden}
        .loading-progress{height:100%;width:0%;background:linear-gradient(90deg,var(--primary-color) 0%,var(--secondary-color) 100%);border-radius:3px;animation:loading 3s infinite}
        @keyframes loading{0%{width:0%}50%{width:70%}100%{width:100%}}
        .upload-section{display:none}
        .upload-area{border:3px dashed var(--primary-color);border-radius:15px;padding:40px;text-align:center;cursor:pointer;transition:all .3s ease;margin-bottom:30px;background:rgba(99,102,241,.1)}
        .upload-area:hover{border-color:var(--secondary-color);background:rgba(139,92,246,.1)}
        .upload-area.drag-over{background:rgba(139,92,246,.2);border-color:var(--secondary-color)}
        input[type=file]{display:none}
        .upload-icon{font-size:48px;margin-bottom:10px}
        .btn{
            background:linear-gradient(135deg,var(--primary-color) 0%,var(--secondary-color) 100%);
            color:#fff;border:none;padding:12px 30px;border-radius:25px;font-size:16px;cursor:pointer;
            transition:all .2s ease;margin:10px 5px;font-weight:500
        }
        .btn:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 5px 15px rgba(99,102,241,.4)}
        .btn:disabled{opacity:.5;cursor:not-allowed;transform:none}
        .btn-secondary{background:var(--card-color)}
        .image-list{margin-top:30px}
        .image-item{background:var(--card-color);border-radius:15px;padding:20px;margin-bottom:20px;border:1px solid rgba(255,255,255,.1)}
        .image-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;flex-wrap:wrap;gap:10px}
        .image-name{font-weight:500;font-size:16px;word-break:break-all;flex:1;min-width:200px}
        .image-size{font-size:14px;color:var(--text-secondary)}
        .image-preview{display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-bottom:15px}
        .preview-box{text-align:center}
        .preview-title{font-size:14px;color:var(--text-secondary);margin-bottom:8px}
        .preview-img{width:100%;height:150px;object-fit:contain;border-radius:8px;background:var(--background-color)}
        .progress-container{width:100%;height:8px;background:rgba(255,255,255,.1);border-radius:4px;overflow:hidden;margin-top:10px}
        .progress-bar{height:100%;background:linear-gradient(90deg,var(--primary-color) 0%,var(--secondary-color) 100%);width:0;transition:width .3s ease;border-radius:4px}
        .progress-text{display:flex;justify-content:space-between;font-size:12px;color:var(--text-secondary);margin-top:5px}
        .status{padding:8px 12px;border-radius:8px;font-size:14px;display:inline-block;margin-top:10px}
        .status.pending{background:rgba(251,191,36,.2);color:var(--warning-color)}
        .status.processing{background:rgba(96,165,250,.2);color:var(--info-color)}
        .status.completed{background:rgba(74,222,128,.2);color:var(--accent-color)}
        .status.error{background:rgba(248,113,113,.2);color:var(--error-color)}
        .processing-section{display:none}
        .processing-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}
        .processing-title{font-size:20px;font-weight:500}
        .processing-stats{font-size:14px;color:var(--text-secondary)}
        .empty-state{text-align:center;padding:40px 20px;color:var(--text-secondary)}
        .empty-icon{font-size:48px;margin-bottom:15px;opacity:.5}
        .settings-panel{background:var(--card-color);border-radius:10px;padding:20px;margin-bottom:20px;border:1px solid rgba(255,255,255,.1)}
        .settings-panel h3{margin-bottom:15px;font-size:16px}
        .setting-item{margin-bottom:15px}
        .setting-item label{display:block;margin-bottom:5px;font-size:14px;color:var(--text-secondary)}
        .setting-item input{width:100%;padding:10px;border:1px solid rgba(255,255,255,.2);border-radius:5px;background:var(--surface-color);color:var(--text-primary)}
        .setting-item input[type=range]{padding:5px 0}
        .setting-item span{margin-left:10px;color:var(--text-primary)}
        .execution-info{background:rgba(96,165,250,.1);border-left:4px solid var(--info-color);padding:15px;border-radius:0 10px 10px 0;margin-bottom:20px;font-size:14px}
        .execution-info h4{margin-bottom:8px;color:var(--info-color)}
        .execution-info p{margin-bottom:5px;color:var(--text-primary)}
        .provider-badge{display:inline-block;padding:3px 8px;border-radius:12px;font-size:12px;font-weight:bold;margin-right:5px}
        .provider-badge.webgpu{background:var(--accent-color);color:#fff}
        .provider-badge.wasm{background:var(--warning-color);color:#fff}
        .provider-badge.cpu{background:#64748b;color:#fff}
        .navigation{display:flex;justify-content:space-between;margin-top:30px;gap:10px}
        .error-message{background:rgba(248,113,113,.2);border-left:4px solid var(--error-color);padding:15px;border-radius:0 10px 10px 0;margin-bottom:20px;font-size:14px;color:var(--error-color)}
        .debug-panel{background:var(--card-color);border-radius:10px;padding:20px;margin-bottom:20px;border:1px solid rgba(255,255,255,.1);max-height:600px;overflow-y:auto;display:none}
        .debug-panel h3{margin-bottom:15px;font-size:16px;position:sticky;top:0;background:var(--card-color);padding:10px 0;z-index:10}
        .debug-log{display:flex;flex-direction:column;gap:20px}
        .debug-image-section{border:2px solid rgba(96,165,250,.3);border-radius:10px;padding:15px;background:rgba(15,23,42,.5)}
        .debug-image-header{background:linear-gradient(135deg,rgba(99,102,241,.2) 0%,rgba(139,92,246,.2) 100%);border-radius:8px;padding:15px;margin-bottom:15px;border-left:4px solid var(--info-color)}
        .debug-image-title{font-size:18px;font-weight:bold;color:var(--info-color);margin-bottom:12px;display:flex;align-items:center;gap:10px}
        .debug-image-title::before{content:"üñºÔ∏è";font-size:24px}
        .debug-image-info{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px}
        .debug-info-item{font-size:12px;color:var(--text-secondary);background:rgba(15,23,42,.5);padding:6px 10px;border-radius:5px}
        .debug-info-item strong{color:var(--text-primary);min-width:60px;display:inline-block}
        .debug-tiles-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:15px}
        .debug-tile{background:var(--surface-color);border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,.1);transition:all .3s ease;overflow:hidden}
        .debug-tile:hover{transform:translateY(-3px);box-shadow:0 8px 20px rgba(99,102,241,.3);border-color:var(--primary-color)}
        .debug-tile-header{font-size:12px;font-weight:bold;color:var(--text-primary);margin-bottom:10px;text-align:center;padding:6px;background:rgba(99,102,241,.1);border-radius:5px}
        .debug-tile-content{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
        .debug-image-container{text-align:center}
        .debug-image-label{font-size:10px;font-weight:bold;margin-bottom:5px;text-transform:uppercase;letter-spacing:.5px}
        .debug-image-before .debug-image-label{color:var(--accent-color)}
        .debug-image-after .debug-image-label{color:var(--secondary-color)}
        .debug-image{width:100%;height:90px;object-fit:cover;border-radius:5px;cursor:pointer;transition:all .2s ease;background:var(--background-color)}
        .debug-image:hover{transform:scale(1.05);box-shadow:0 4px 12px rgba(0,0,0,.4)}
        .debug-image-before .debug-image{border:2px solid var(--accent-color)}
        .debug-image-after .debug-image{border:2px solid var(--secondary-color)}
        .debug-tile-info{font-size:10px;color:var(--text-secondary);background:rgba(15,23,42,.7);padding:8px;border-radius:5px}
        .debug-tile-info div{margin-bottom:4px;display:flex;justify-content:space-between}
        .debug-tile-info div:last-child{margin-bottom:0}
        .debug-tile-info strong{color:var(--text-primary)}
        .debug-panel::-webkit-scrollbar{width:10px}
        .debug-panel::-webkit-scrollbar-track{background:rgba(255,255,255,.05);border-radius:10px}
        .debug-panel::-webkit-scrollbar-thumb{background:linear-gradient(180deg,var(--primary-color) 0%,var(--secondary-color) 100%);border-radius:10px}
        .debug-panel::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,var(--secondary-color) 0%,var(--primary-color) 100%)}
        .copyright{text-align:center;margin-top:20px;font-size:14px;color:var(--text-secondary)}
        .copyright a{color:var(--primary-color);text-decoration:none;transition:color .2s ease}
        .copyright a:hover{color:var(--secondary-color);text-decoration:underline}
        @media(max-width:768px){.container{padding:20px}h1{font-size:24px}.subtitle{font-size:14px}.upload-area{padding:30px 20px}.image-preview{grid-template-columns:1fr}.btn{padding:10px 20px;font-size:14px;margin:5px}.settings-panel{padding:15px}.debug-tiles-grid{grid-template-columns:repeat(auto-fill,minmax(160px,1fr))}.debug-panel{max-height:400px}}
        @media(max-width:480px){.container{padding:15px}h1{font-size:20px}.upload-area{padding:20px 15px}.upload-icon{font-size:36px}.btn{padding:8px 16px;font-size:13px}.navigation{flex-direction:column}.debug-tiles-grid{grid-template-columns:1fr}.debug-tile-content{grid-template-columns:1fr}}
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® ks-unwatermarker</h1>
        <p class="subtitle">Upload images to remove watermarks using AI</p>

        <!-- Loading Screen -->
        <div class="loading-screen" id="loadingScreen">
            <div class="loading-icon">‚è≥</div>
            <div class="loading-text">Loading AI Model</div>
            <div class="loading-subtext">This may take a moment...</div>
            <div class="loading-bar"><div class="loading-progress"></div></div>
            <div class="execution-info" id="executionInfo" style="margin-top:30px;width:100%">
                <h4>Execution Provider Information</h4>
                <p id="providerStatus">Detecting available execution providers...</p>
            </div>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="settings-panel">
                <h3>‚öôÔ∏è Processing Settings</h3>
                <div class="setting-item">
                    <label for="tileSize">Tile Size (for large images):</label>
                    <input type="number" id="tileSize" value="512" min="64" max="1024" step="64">
                </div>
                <div class="setting-item">
                    <label for="overlap">Tile Overlap (pixels):</label>
                    <input type="number" id="overlap" value="64" min="0" max="128">
                </div>
                <div class="setting-item">
                    <label for="inputSize">Model Input Size:</label>
                    <input type="number" id="inputSize" value="256" min="64" max="512" step="64">
                </div>
                <div class="setting-item">
                    <label for="enablePostProcessing">Enable Post-Processing:</label>
                    <input type="checkbox" id="enablePostProcessing" checked>
                </div>
            </div>

            <div class="debug-panel" id="debugPanel" style="display:none">
                <h3>üîç Debug Information</h3>
                <div class="debug-log" id="debugLog"></div>
            </div>

            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <p>Click to upload or drag & drop images</p>
                <p style="font-size:12px;color:#94a3b8;margin-top:5px">Supports JPG, PNG</p>
                <input type="file" id="fileInput" accept="image/*" multiple>
            </div>

            <div class="image-list" id="imageList"></div>

            <div class="navigation">
                <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                <button class="btn" id="nextBtn" disabled>Next</button>
            </div>
        </div>

        <!-- Processing Section -->
        <div class="processing-section" id="processingSection">
            <div class="processing-header">
                <div class="processing-title">Processing Images</div>
                <div class="processing-stats" id="processingStats">0/0 completed</div>
            </div>
            <div class="image-list" id="processingList"></div>
            <div class="navigation">
                <button class="btn btn-secondary" id="backBtn">Back</button>
                <button class="btn" id="downloadAllBtn" disabled>Download All</button>
            </div>
        </div>
    </div>

    <div class="copyright">
        ¬© <a href="https://github.com/cziter15" target="_blank" rel="noopener noreferrer">K. STREHLAU</a>
    </div>

    <script>
        const MODEL_URL = 'model.onnx';
        const MODEL_DATA_URL = 'model.onnx.data';
        function logDebug(m){console.log(m)}
        async function checkWebGPUSupport(){
            const r={supported:false,error:null,details:{}};
            try{if(!navigator.gpu){r.error='navigator.gpu not found';return r}
            const a=await navigator.gpu.requestAdapter();if(!a){r.error='No GPU adapter';return r}
            if(typeof a.requestAdapterInfo==='function')try{r.details.adapter=await a.requestAdapterInfo()}catch{}
            const d=await a.requestDevice();if(!d){r.error='Failed to create GPU device';return r}
            r.supported=true;return r}catch(e){r.error=`WebGPU: ${e.message}`;return r}}
        async function updateExecutionProviderStatus(){
            const ps=document.getElementById('providerStatus'),w=await checkWebGPUSupport(),g=!!(document.createElement('canvas').getContext('webgl')||document.createElement('canvas').getContext('experimental-webgl'));
            let h='Available: ';
            if(w.supported)h+='<span class="provider-badge webgpu">WebGPU</span> ';
            if(g)h+='<span class="provider-badge wasm">WASM</span> ';
            h+='<span class="provider-badge cpu">CPU</span>';
            if(w.supported){h+='<p style="margin-top:8px;color:#4ade80;font-weight:bold">‚úì WebGPU ready</p>'}else{h+='<p style="margin-top:8px;color:#fbbf24;font-weight:bold">‚ö† WebGPU unavailable</p>'}
            ps.innerHTML=h}
        class ONNXWatermarkRemover{
            constructor(){
                this.session=null;this.modelLoaded=false;this.inputSize=256;this.tileSize=512;this.overlap=64;
                this.modelPath=MODEL_URL;this.modelDataPath=MODEL_DATA_URL;this.executionProvider=null;this.currentImageDebugId=null;this.enablePostProcessing=true}
            async loadModel(mp,mdp){
                try{logDebug('Loading model‚Ä¶');const mr=await fetch(mp);if(!mr.ok)throw new Error(mr.statusText);
                const mb=await mr.arrayBuffer();let edb=null;
                try{const dr=await fetch(mdp);if(dr.ok)edb=await dr.arrayBuffer()}catch{}
                const so={executionProviders:['webgpu','wasm','cpu']};if(edb)so.externalData=[{data:edb,path:'model.onnx.data'}];
                const s=await ort.InferenceSession.create(mb,so);
                this.executionProvider=s.handler?.backendName||'unknown';this.session=s;this.modelLoaded=true;return true}catch(e){console.error(e);return false}}
            async processImage(img,pcb,name='Unknown'){
                if(!this.modelLoaded)throw new Error('Model not loaded');
                const{width:w,height:h}=img;if(w<64||h<64)throw new Error('Image too small (min 64√ó64)');
                logDebug(`Processing ${name} (${w}√ó${h})`);
                return this.processTiled(img,pcb,name)}
            async processTiled(src,pcb,name){
                const{width:ow,height:oh}=src;
                const out=document.createElement('canvas');out.width=ow;out.height=oh;
                const octx=out.getContext('2d',{willReadFrequently:true});octx.fillRect(0,0,ow,oh);
                // whole-image shortcut for small inputs
                if(ow<=this.tileSize&&oh<=this.tileSize){logDebug('Small image ‚Äì no tiling');const pc=await this.processWholeImage(src,pcb,name);octx.drawImage(pc,0,0);if(pcb)pcb(100,'Processing complete');return out}
                const step=this.tileSize-this.overlap,tiles=[];
                for(let y=0;y<oh;y+=step)for(let x=0;x<ow;x+=step)tiles.push({x,y,w:Math.min(this.tileSize,ow-x),h:Math.min(this.tileSize,oh-y)});
                logDebug(`${tiles.length} tiles (size=${this.tileSize}, overlap=${this.overlap})`);
                // debug panel
                const dlog=document.getElementById('debugLog');
                if(dlog){
                    const sec=document.createElement('div');sec.className='debug-image-section';this.currentImageDebugId='debug-'+Date.now();sec.id=this.currentImageDebugId;
                    sec.innerHTML=`<div class="debug-image-header"><div class="debug-image-title">${name}</div><div class="debug-image-info">
                        <div class="debug-info-item"><strong>Dimensions:</strong> ${ow}√ó${oh}</div>
                        <div class="debug-info-item"><strong>Tile Size:</strong> ${this.tileSize}</div>
                        <div class="debug-info-item"><strong>Overlap:</strong> ${this.overlap}</div>
                        <div class="debug-info-item"><strong>Tiles:</strong> ${tiles.length}</div>
                        <div class="debug-info-item"><strong>Model Input:</strong> ${this.inputSize}</div>
                        <div class="debug-info-item"><strong>Provider:</strong> ${this.executionProvider.toUpperCase()}</div>
                    </div></div><div class="debug-tiles-grid" id="${this.currentImageDebugId}-tiles"></div>`;
                    dlog.appendChild(sec);sec.scrollIntoView({behavior:'smooth',block:'start'})
                }
                for(let i=0;i<tiles.length;i++){
                    await new Promise(r=>setTimeout(r,5));
                    try{const pt=await this.processTile(src,tiles[i],i);this.blendTile(octx,pt,tiles[i],ow,oh)}catch(e){logDebug(`Tile ${i} error: ${e.message}`)}
                    const p=Math.round(((i+1)/tiles.length)*100);if(pcb)pcb(p,`Tile ${i+1}/${tiles.length} (${this.executionProvider.toUpperCase()})‚Ä¶`)
                }
                if(this.enablePostProcessing){if(pcb)pcb(95,'Post-processing‚Ä¶');await this.postProcess(out)}
                return out
            }
            async processWholeImage(src,pcb,name){
                const dlog=document.getElementById('debugLog');
                if(dlog){
                    const sec=document.createElement('div');sec.className='debug-image-section';this.currentImageDebugId='debug-'+Date.now();sec.id=this.currentImageDebugId;
                    sec.innerHTML=`<div class="debug-image-header"><div class="debug-image-title">${name}</div><div class="debug-image-info">
                        <div class="debug-info-item"><strong>Dimensions:</strong> ${src.width}√ó${src.height}</div>
                        <div class="debug-info-item"><strong>Processing:</strong> Whole Image</div>
                        <div class="debug-info-item"><strong>Model Input:</strong> ${this.inputSize}</div>
                        <div class="debug-info-item"><strong>Provider:</strong> ${this.executionProvider.toUpperCase()}</div>
                    </div></div><div class="debug-tiles-grid" id="${this.currentImageDebugId}-tiles"></div>`;
                    dlog.appendChild(sec);sec.scrollIntoView({behavior:'smooth',block:'start'})
                }
                const beforeCvs=document.createElement('canvas');beforeCvs.width=src.width;beforeCvs.height=src.height;
                const bctx=beforeCvs.getContext('2d');bctx.drawImage(src,0,0);
                const before64=beforeCvs.toDataURL('image/png');
                const inCvs=document.createElement('canvas');inCvs.width=this.inputSize;inCvs.height=this.inputSize;
                const ictx=inCvs.getContext('2d');ictx.imageSmoothingEnabled=true;ictx.imageSmoothingQuality='high';
                ictx.drawImage(beforeCvs,0,0,src.width,src.height,0,0,this.inputSize,this.inputSize);
                const iData=ictx.getImageData(0,0,this.inputSize,this.inputSize);
                const inT=this.imageDataToTensor(iData);
                const feeds={};feeds[this.session.inputNames[0]]=inT;
                const res=await this.session.run(feeds);
                const outT=res[this.session.outputNames[0]];
                const outImgData=this.tensorToImageData(outT);
                const modelCvs=document.createElement('canvas');modelCvs.width=this.inputSize;modelCvs.height=this.inputSize;
                modelCvs.getContext('2d').putImageData(outImgData,0,0);
                const outCvs=document.createElement('canvas');outCvs.width=src.width;outCvs.height=src.height;
                const octx=outCvs.getContext('2d');octx.imageSmoothingEnabled=true;octx.imageSmoothingQuality='high';
                octx.drawImage(modelCvs,0,0,this.inputSize,this.inputSize,0,0,src.width,src.height);
                const after64=outCvs.toDataURL('image/png');
                const grid=document.getElementById(this.currentImageDebugId+'-tiles');
                if(grid){
                    const tile=document.createElement('div');tile.className='debug-tile';
                    tile.innerHTML=`
                        <div class="debug-tile-header">Whole Image</div>
                        <div class="debug-tile-content">
                            <div class="debug-image-container debug-image-before"><div class="debug-image-label">Before</div><img class="debug-image" src="${before64}" onclick="window.open('${before64}','_blank')"></div>
                            <div class="debug-image-container debug-image-after"><div class="debug-image-label">After</div><img class="debug-image" src="${after64}" onclick="window.open('${after64}','_blank')"></div>
                        </div>
                        <div class="debug-tile-info">
                            <div><strong>Size:</strong> <span>${src.width}√ó${src.height}</span></div>
                            <div><strong>Input:</strong> <span>${inT.dims.join('√ó')}</span></div>
                            <div><strong>Output:</strong> <span>${outT.dims.join('√ó')}</span></div>
                        </div>`;
                    grid.appendChild(tile)
                }
                return outCvs
            }
            async processTile(src,tile,idx){
                const tCvs=document.createElement('canvas');tCvs.width=tile.w;tCvs.height=tile.h;
                const tctx=tCvs.getContext('2d');tctx.drawImage(src,tile.x,tile.y,tile.w,tile.h,0,0,tile.w,tile.h);
                const before64=tCvs.toDataURL('image/png');
                const inCvs=document.createElement('canvas');inCvs.width=this.inputSize;inCvs.height=this.inputSize;
                const ictx=inCvs.getContext('2d');ictx.filter='blur(0.5px)';
                ictx.drawImage(tCvs,0,0,tile.w,tile.h,0,0,this.inputSize,this.inputSize);ictx.filter='none';
                const iData=ictx.getImageData(0,0,this.inputSize,this.inputSize);
                const inT=this.imageDataToTensor(iData);
                const feeds={};feeds[this.session.inputNames[0]]=inT;
                const res=await this.session.run(feeds);
                const outT=res[this.session.outputNames[0]];
                const outImgData=this.tensorToImageData(outT);
                const mCvs=document.createElement('canvas');mCvs.width=this.inputSize;mCvs.height=this.inputSize;
                mCvs.getContext('2d').putImageData(outImgData,0,0);
                const oCvs=document.createElement('canvas');oCvs.width=tile.w;oCvs.height=tile.h;
                const octx=oCvs.getContext('2d');octx.filter='blur(0.3px)';
                octx.drawImage(mCvs,0,0,this.inputSize,this.inputSize,0,0,tile.w,tile.h);octx.filter='none';
                const after64=oCvs.toDataURL('image/png');
                const grid=document.getElementById(this.currentImageDebugId+'-tiles');
                if(grid){
                    const tileDiv=document.createElement('div');tileDiv.className='debug-tile';
                    tileDiv.innerHTML=`
                        <div class="debug-tile-header">Tile #${idx+1} (${tile.x},${tile.y})</div>
                        <div class="debug-tile-content">
                            <div class="debug-image-container debug-image-before"><div class="debug-image-label">Before</div><img class="debug-image" src="${before64}" onclick="window.open('${before64}','_blank')"></div>
                            <div class="debug-image-container debug-image-after"><div class="debug-image-label">After</div><img class="debug-image" src="${after64}" onclick="window.open('${after64}','_blank')"></div>
                        </div>
                        <div class="debug-tile-info">
                            <div><strong>Size:</strong> <span>${tile.w}√ó${tile.h}</span></div>
                            <div><strong>Input:</strong> <span>${inT.dims.join('√ó')}</span></div>
                            <div><strong>Output:</strong> <span>${outT.dims.join('√ó')}</span></div>
                        </div>`;
                    grid.appendChild(tileDiv)
                }
                return oCvs
            }
            blendTile(octx,tileCanvas,tile,ow,oh){
                const tctx=tileCanvas.getContext('2d',{willReadFrequently:true});
                const tID=tctx.getImageData(0,0,tile.w,tile.h),tD=tID.data;
                const oID=octx.getImageData(tile.x,tile.y,tile.w,tile.h),oD=oID.data;
                const fs=Math.min(this.overlap,16);
                for(let ty=0;ty<tile.h;ty++){
                    for(let tx=0;tx<tile.w;tx++){
                        const p=(ty*tile.w+tx)*4;let bf=1;
                        if(tile.x>0&&tx<fs)bf*=tx/fs;
                        if(tile.y>0&&ty<fs)bf*=ty/fs;
                        if(tile.x+tile.w<ow&&tx>=tile.w-fs)bf*=(tile.w-tx)/fs;
                        if(tile.y+tile.h<oh&&ty>=tile.h-fs)bf*=(tile.h-ty)/fs;
                        oD[p]=Math.round(oD[p]*(1-bf)+tD[p]*bf);
                        oD[p+1]=Math.round(oD[p+1]*(1-bf)+tD[p+1]*bf);
                        oD[p+2]=Math.round(oD[p+2]*(1-bf)+tD[p+2]*bf);
                        oD[p+3]=255
                    }
                }
                octx.putImageData(oID,tile.x,tile.y)
            }
            async postProcess(cvs){
                const ctx=cvs.getContext('2d');
                ctx.filter='blur(0.5px)';const temp=document.createElement('canvas');temp.width=cvs.width;temp.height=cvs.height;
                temp.getContext('2d').drawImage(cvs,0,0);ctx.filter='none';ctx.drawImage(temp,0,0);
                const id=ctx.getImageData(0,0,cvs.width,cvs.height);
                ctx.putImageData(this.applyConvolution(id,[0,-0.25,0,-0.25,2,-0.25,0,-0.25,0]),0,0)
            }
            applyConvolution(iD,k){
                const w=iD.width,h=iD.height,d=iD.data,o=new ImageData(w,h),od=o.data;
                const ks=Math.sqrt(k.length),hk=Math.floor(ks/2);
                for(let y=0;y<h;y++){
                    for(let x=0;x<w;x++){
                        let r=0,g=0,b=0;
                        for(let ky=0;ky<ks;ky++){
                            for(let kx=0;kx<ks;kx++){
                                const px=Math.min(w-1,Math.max(0,x+kx-hk)),py=Math.min(h-1,Math.max(0,y+ky-hk));
                                const idx=(py*w+px)*4,wt=k[ky*ks+kx];
                                r+=d[idx]*wt;g+=d[idx+1]*wt;b+=d[idx+2]*wt
                            }
                        }
                        const idx=(y*w+x)*4;
                        od[idx]=Math.min(255,Math.max(0,r));
                        od[idx+1]=Math.min(255,Math.max(0,g));
                        od[idx+2]=Math.min(255,Math.max(0,b));
                        od[idx+3]=d[idx+3]
                    }
                }
                return o
            }
            imageDataToTensor(iD){
                const{w,w:data}=iD;
                const t=new Float32Array(3*w*h);
                for(let i=0;i<h;i++){
                    for(let j=0;j<w;j++){
                        const p=i*w+j,dx=p*4;
                        t[p]=data[dx]/255;
                        t[w*h+p]=data[dx+1]/255;
                        t[w*h*2+p]=data[dx+2]/255
                    }
                }
                return new ort.Tensor('float32',t,[1,3,h,w])
            }
            tensorToImageData(tensor){
                const[d,b,c,h,w]=tensor.dims;
                if(b!==1||c!==3)throw new Error(`Bad shape [${b},${c},${h},${w}]`);
                const src=tensor.data,img=new ImageData(w,h),dst=img.data;
                for(let i=0;i<h;i++){
                    for(let j=0;j<w;j++){
                        const p=i*w+j,dx=p*4;
                        let r=src[p],g=src[w*h+p],b=src[w*h*2+p];
                        // if model outputs [-1,1] uncomment next 3 lines
                        // r=(r+1)/2; g=(g+1)/2; b=(b+1)/2;
                        r=Math.max(0,Math.min(1,r));
                        g=Math.max(0,Math.min(1,g));
                        b=Math.max(0,Math.min(1,b));
                        dst[dx]=Math.round(r*255);
                        dst[dx+1]=Math.round(g*255);
                        dst[dx+2]=Math.round(b*255);
                        dst[dx+3]=255
                    }
                }
                return img
            }
        }

        class ImageManager{
            constructor(){this.images=[];this.processed=[]}
            addImage(file){return new Promise((res,rej)=>{
                if(!file.type.match('image.*'))return rej('Not an image');
                if(file.size>20e6)return rej('>20 MB');
                const r=new FileReader();r.onload=e=>{
                    const img=new Image();img.onload=()=>{
                        const o={id:Date.now()+Math.random(),file,name:file.name,size:file.size,width:img.width,height:img.height,image:img,dataUrl:e.target.result,status:'pending'};
                        this.images.push(o);res(o)
                    };img.onerror=()=>rej('Bad image');img.src=e.target.result
                };r.onerror=()=>rej('Read failed');r.readAsDataURL(file)
            })}
            removeImage(id){this.images=this.images.filter(i=>i.id!==id)}
            clearAll(){this.images=[];this.processed=[]}
            getImages(){return this.images}
            getProcessedImages(){return this.processed}
            updateImageStatus(id,st){const i=this.images.find(x=>x.id===id);if(i)i.status=st}
            addProcessedImage(id,cvs){const o=this.images.find(x=>x.id===id);if(o)this.processed.push({id,name:o.name,canvas:cvs,status:'completed'})}
        }

        class UIController{
            constructor(r,im){this.remover=r;this.im=im;this.init();this.attach()}
            init(){
                this.load=document.getElementById('loadingScreen');
                this.up=document.getElementById('uploadSection');
                this.pr=document.getElementById('processingSection');
                this.area=document.getElementById('uploadArea');
                this.fIn=document.getElementById('fileInput');
                this.list=document.getElementById('imageList');
                this.pList=document.getElementById('processingList');
                this.nBtn=document.getElementById('nextBtn');
                this.bBtn=document.getElementById('backBtn');
                this.cBtn=document.getElementById('clearBtn');
                this.dBtn=document.getElementById('downloadAllBtn');
                this.tSize=document.getElementById('tileSize');
                this.ov=document.getElementById('overlap');
                this.inSize=document.getElementById('inputSize');
                this.post=document.getElementById('enablePostProcessing');
                this.stats=document.getElementById('processingStats');
                this.dPan=document.getElementById('debugPanel');
                this.dLog=document.getElementById('debugLog')
            }
            attach(){
                this.area.onclick=()=>this.fIn.click();
                this.area.ondragover=e=>{e.preventDefault();this.area.classList.add('drag-over')};
                this.area.ondragleave=()=>this.area.classList.remove('drag-over');
                this.area.ondrop=e=>{e.preventDefault();this.area.classList.remove('drag-over');this.handleFiles(e.dataTransfer.files)};
                this.fIn.onchange=e=>this.handleFiles(e.target.files);
                this.nBtn.onclick=()=>this.showProcessing();
                this.bBtn.onclick=()=>this.showUpload();
                this.cBtn.onclick=()=>{this.im.clearAll();this.render();this.updateNext();if(this.dLog)this.dLog.innerHTML=''};
                this.dBtn.onclick=()=>this.downloadAll();
                this.tSize.onchange=()=>{const v=parseInt(this.tSize.value);if(v>=64&&v<=1024)this.remover.tileSize=v};
                this.ov.onchange=()=>{const v=parseInt(this.ov.value);if(v>=0&&v<=128)this.remover.overlap=v};
                this.inSize.onchange=()=>{const v=parseInt(this.inSize.value);if(v>=64&&v<=512)this.remover.inputSize=v};
                this.post.onchange=()=>this.remover.enablePostProcessing=this.post.checked
            }
            async handleFiles(fs){for(const f of fs)try{await this.im.addImage(f);this.render();this.updateNext()}catch(e){alert(e.message)}}
            render(){
                const imgs=this.im.getImages();
                if(!imgs.length){this.list.innerHTML='';return}
                this.list.innerHTML=imgs.map(i=>`<div class="image-item">
                    <div class="image-header"><div class="image-name">${i.name}</div><div class="image-size">${this.fmt(i.size)}</div><button class="btn btn-secondary" style="padding:5px 10px;font-size:12px" onclick="ui.removeImage(${i.id})">Remove</button></div>
                    <div class="image-preview"><div class="preview-box"><div class="preview-title">Original</div><img class="preview-img" src="${i.dataUrl}"></div><div class="preview-box"><div class="preview-title">Processed</div><div class="preview-img" style="background:var(--background-color);display:flex;align-items:center;justify-content:center"><span style="color:var(--text-secondary)">Not processed yet</span></div></div></div>
                    <div class="status ${i.status}">${this.stxt(i.status)}</div>
                </div>`).join('')
            }
            renderProcessing(){
                const imgs=this.im.getImages(),proc=this.im.getProcessedImages();
                if(!imgs.length){this.pList.innerHTML='<div class="empty-state"><div class="empty-icon">üì∑</div><p>No images to process</p></div>';return}
                this.pList.innerHTML=imgs.map(i=>{
                    const p=proc.find(x=>x.id===i.id);
                    let ph='';
                    if(p){
                        const ctx=p.canvas.getContext('2d');
                        const id=ctx.getImageData(0,0,1,1);
                        const has=id.data[0]||id.data[1]||id.data[2];
                        ph=has?`<img class="preview-img" src="${p.canvas.toDataURL()}">`:'<div class="preview-img" style="background:var(--background-color);display:flex;align-items:center;justify-content:center;flex-direction:column"><span style="color:var(--text-secondary)">Processing result</span></div>'
                    }else{ph='<div class="preview-img" style="background:var(--background-color);display:flex;align-items:center;justify-content:center"><span style="color:var(--text-secondary)">Processing‚Ä¶</span></div>'}
                    return`<div class="image-item">
                        <div class="image-header"><div class="image-name">${i.name}</div><div class="image-size">${this.fmt(i.size)}</div></div>
                        <div class="image-preview"><div class="preview-box"><div class="preview-title">Original</div><img class="preview-img" src="${i.dataUrl}"></div><div class="preview-box"><div class="preview-title">Processed</div>${ph}</div></div>
                        <div class="progress-container"><div class="progress-bar" id="progress-${i.id}" style="width:${p?'100%':'0%'}"></div></div>
                        <div class="progress-text"><span id="progress-text-${i.id}">${p?'Completed':'Waiting to process‚Ä¶'}</span><span>${p?'100%':'0%'}</span></div>
                        <div class="status ${i.status}">${this.stxt(i.status)}</div>
                    </div>`
                }).join('')
            }
            removeImage(id){this.im.removeImage(id);this.render();this.updateNext()}
            updateNext(){this.nBtn.disabled=!this.im.getImages().length}
            showUpload(){this.up.style.display='block';this.pr.style.display='none'}
            showProcessing(){
                this.up.style.display='none';this.pr.style.display='block';
                if(this.dLog)this.dLog.innerHTML='';
                if(this.dPan)this.dPan.style.display='block';
                this.renderProcessing();this.processImages()
            }
            async processImages(){
                const imgs=this.im.getImages();let done=0;this.updateStats(done,imgs.length);
                for(const i of imgs){
                    try{
                        this.im.updateImageStatus(i.id,'processing');this.renderProcessing();
                        const bar=document.getElementById(`progress-${i.id}`),txt=document.getElementById(`progress-text-${i.id}`);
                        const cvs=await this.remover.processImage(i.image,(p,m)=>{
                            if(bar)bar.style.width=p+'%';if(txt)txt.textContent=m;const pc=txt.nextElementSibling;if(pc)pc.textContent=p+'%'
                        },i.name);
                        this.im.addProcessedImage(i.id,cvs);this.im.updateImageStatus(i.id,'completed');done++;
                        this.updateStats(done,imgs.length);this.renderProcessing();if(done===imgs.length)this.dBtn.disabled=false
                    }catch(e){console.error(e);this.im.updateImageStatus(i.id,'error');this.renderProcessing();done++;this.updateStats(done,imgs.length)}
                }
            }
            updateStats(c,t){this.stats.textContent=`${c}/${t} completed`}
            downloadAll(){
                const p=this.im.getProcessedImages();if(!p.length)return;
                p.forEach((img,i)=>setTimeout(()=>img.canvas.toBlob(b=>{
                    const u=URL.createObjectURL(b),a=document.createElement('a');
                    a.download=img.name.replace(/\.[^.]+$/,'')+'_watermark_removed.png';a.href=u;a.click();URL.revokeObjectURL(u)
                },'image/png',1),i*100))
            }
            fmt(b){return b<1024?b+' B':b<1048576?Math.round(b/1024)+' KB':Math.round(b/1048576*10)/10+' MB'}
            stxt(s){return{pending:'‚è≥ Pending',processing:'‚öôÔ∏è Processing‚Ä¶',completed:'‚úÖ Completed',error:'‚ùå Error'}[s]||s}
        }

        let ui,remover,im;
        async function init(){
            await updateExecutionProviderStatus();
            remover=new ONNXWatermarkRemover();im=new ImageManager();ui=new UIController(remover,im);
            // improved defaults
            document.getElementById('tileSize').value=512;
            document.getElementById('overlap').value=64;
            document.getElementById('inputSize').value=256;
            document.getElementById('enablePostProcessing').checked=true;
            remover.tileSize=512;remover.overlap=64;remover.inputSize=256;remover.enablePostProcessing=true;
            const ok=await remover.loadModel(MODEL_URL,MODEL_DATA_URL);
            if(ok){document.getElementById('loadingScreen').style.display='none';document.getElementById('uploadSection').style.display='block'}
            else{document.getElementById('loadingScreen').innerHTML=`<div class="error-message"><h4>‚ùå Failed to load model</h4><p>Ensure model.onnx (+ .data) are present.</p></div><button class="btn" onclick="location.reload()">üîÑ Retry</button>`}
        }
        window.onload=init;
    </script>
</body>
</html>