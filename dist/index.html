<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ks-unwatermarker</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/ort.all.min.js"></script>
    <style>
        :root {
            --primary-color: #6366f1;
            --secondary-color: #8b5cf6;
            --background-color: #0f172a;
            --surface-color: #1e293b;
            --card-color: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --accent-color: #4ade80;
            --error-color: #f87171;
            --warning-color: #fbbf24;
            --info-color: #60a5fa;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            background-color: var(--surface-color);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: var(--text-primary);
            margin-bottom: 10px;
            font-size: 28px;
            text-align: center;
        }
        
        .subtitle {
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 16px;
            text-align: center;
        }
        
        /* Loading Screen */
        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }
        
        .loading-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        .loading-text {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        .loading-subtext {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .loading-bar {
            width: 100%;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 30px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            border-radius: 3px;
            animation: loading 3s infinite;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
        
        /* Upload Section */
        .upload-section {
            display: none;
        }
        
        .upload-area {
            border: 3px dashed var(--primary-color);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
            background-color: rgba(99, 102, 241, 0.1);
        }
        
        .upload-area:hover {
            border-color: var(--secondary-color);
            background-color: rgba(139, 92, 246, 0.1);
        }
        
        .upload-area.drag-over {
            background-color: rgba(139, 92, 246, 0.2);
            border-color: var(--secondary-color);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .btn {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 10px 5px;
            font-weight: 500;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: var(--card-color);
        }
        
        /* Image List */
        .image-list {
            margin-top: 30px;
        }
        
        .image-item {
            background-color: var(--card-color);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .image-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .image-name {
            font-weight: 500;
            font-size: 16px;
            color: var(--text-primary);
            word-break: break-all;
            max-width: 70%;
        }
        
        .image-size {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .image-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .preview-box {
            text-align: center;
        }
        
        .preview-title {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .preview-img {
            width: 100%;
            height: 150px;
            object-fit: contain;
            border-radius: 8px;
            background-color: var(--background-color);
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .status {
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            display: inline-block;
            margin-top: 10px;
        }
        
        .status.pending {
            background-color: rgba(251, 191, 36, 0.2);
            color: var(--warning-color);
        }
        
        .status.processing {
            background-color: rgba(96, 165, 250, 0.2);
            color: var(--info-color);
        }
        
        .status.completed {
            background-color: rgba(74, 222, 128, 0.2);
            color: var(--accent-color);
        }
        
        .status.error {
            background-color: rgba(248, 113, 113, 0.2);
            color: var(--error-color);
        }
        
        /* Processing Section */
        .processing-section {
            display: none;
        }
        
        .processing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .processing-title {
            font-size: 20px;
            font-weight: 500;
        }
        
        .processing-stats {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .empty-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        /* Settings Panel */
        .settings-panel {
            background-color: var(--card-color);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .settings-panel h3 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .setting-item {
            margin-bottom: 15px;
        }
        
        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .setting-item input {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background-color: var(--surface-color);
            color: var(--text-primary);
        }
        
        .setting-item input[type="range"] {
            padding: 5px 0;
        }
        
        .setting-item span {
            display: inline-block;
            margin-left: 10px;
            color: var(--text-primary);
        }
        
        /* Execution Info */
        .execution-info {
            background-color: rgba(96, 165, 250, 0.1);
            border-left: 4px solid var(--info-color);
            padding: 15px;
            border-radius: 0 10px 10px 0;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .execution-info h4 {
            margin-bottom: 8px;
            color: var(--info-color);
        }
        
        .execution-info p {
            margin-bottom: 5px;
            color: var(--text-primary);
        }
        
        .execution-info .provider-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .provider-badge.webgpu {
            background-color: var(--accent-color);
            color: white;
        }
        
        .provider-badge.wasm {
            background-color: var(--warning-color);
            color: white;
        }
        
        .provider-badge.cpu {
            background-color: #64748b;
            color: white;
        }
        
        /* Navigation */
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        
        /* Error Message */
        .error-message {
            background-color: rgba(248, 113, 113, 0.2);
            border-left: 4px solid var(--error-color);
            padding: 15px;
            border-radius: 0 10px 10px 0;
            margin-bottom: 20px;
            font-size: 14px;
            color: var(--error-color);
        }
        
        /* Debug Panel */
        .debug-panel {
            background-color: var(--card-color);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 800px;
            overflow-y: auto;
        }

        .debug-panel h3 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        .debug-log {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .debug-image-header {
            background-color: rgba(15, 23, 42, 0.7);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--info-color);
        }

        .debug-image-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--info-color);
            margin-bottom: 10px;
        }

        .debug-image-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 10px;
        }

        .debug-info-item {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .debug-info-item strong {
            color: var(--text-primary);
        }

        .debug-tiles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .debug-tile {
            background-color: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .debug-tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .debug-tile-header {
            font-size: 12px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-align: center;
        }

        .debug-tile-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .debug-image-container {
            text-align: center;
        }

        .debug-image-label {
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .debug-image-before .debug-image-label {
            color: var(--accent-color);
        }

        .debug-image-after .debug-image-label {
            color: var(--error-color);
        }

        .debug-image {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .debug-image:hover {
            transform: scale(1.05);
        }

        .debug-image-before .debug-image {
            border: 1px solid var(--accent-color);
        }

        .debug-image-after .debug-image {
            border: 1px solid var(--error-color);
        }

        .debug-tile-info {
            font-size: 10px;
            color: var(--text-secondary);
            background-color: rgba(15, 23, 42, 0.7);
            padding: 6px;
            border-radius: 4px;
        }

        .debug-tile-info div {
            margin-bottom: 3px;
        }

        .debug-tile-info div:last-child {
            margin-bottom: 0;
        }

        .debug-tile-info strong {
            color: var(--text-primary);
        }

        /* Scrollbar styling */
        .debug-panel::-webkit-scrollbar {
            width: 8px;
        }

        .debug-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .debug-panel::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.3);
            border-radius: 10px;
        }

        .debug-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(99, 102, 241, 0.5);
        }
        
        /* Copyright */
        .copyright {
            text-align: center;
            margin-top: 20px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .copyright a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .copyright a:hover {
            color: var(--secondary-color);
            text-decoration: underline;
        }
        
        /* Responsive improvements */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            .subtitle {
                font-size: 14px;
            }
            
            .upload-area {
                padding: 30px 20px;
            }
            
            .image-preview {
                grid-template-columns: 1fr;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 14px;
                margin: 5px;
            }
            
            .settings-panel {
                padding: 15px;
            }
            
            .debug-tiles-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 20px;
            }
            
            .upload-area {
                padding: 20px 15px;
            }
            
            .upload-icon {
                font-size: 36px;
            }
            
            .btn {
                padding: 8px 16px;
                font-size: 13px;
            }
            
            .navigation {
                flex-direction: column;
                gap: 10px;
            }
            
            .debug-tiles-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎨 ks-unwatermarker</h1>
        <p class="subtitle">Upload images to remove watermarks using AI</p>
        
        <!-- Loading Screen -->
        <div class="loading-screen" id="loadingScreen">
            <div class="loading-icon">⏳</div>
            <div class="loading-text">Loading AI Model</div>
            <div class="loading-subtext">This may take a moment...</div>
            <div class="loading-bar">
                <div class="loading-progress"></div>
            </div>
            <div class="execution-info" id="executionInfo" style="margin-top: 30px; width: 100%;">
                <h4>Execution Provider Information</h4>
                <p id="providerStatus">Detecting available execution providers...</p>
            </div>
        </div>
        
        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="settings-panel">
                <h3>Processing Settings</h3>
                <div class="setting-item">
                    <label for="tileSize">Tile Size (for large images):</label>
                    <input type="number" id="tileSize" value="256" min="64" max="1024" step="64">
                </div>
                <div class="setting-item">
                    <label for="overlap">Tile Overlap (pixels):</label>
                    <input type="number" id="overlap" value="32" min="0" max="64">
                </div>
                <div class="setting-item">
                    <label for="inputSize">Model Input Size:</label>
                    <input type="number" id="inputSize" value="256" min="64" max="512" step="64">
                </div>
            </div>
            
            <div class="debug-panel" id="debugPanel" style="display: none;">
                <h3>Debug Information</h3>
                <div class="debug-log" id="debugLog"></div>
            </div>
            
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <p>Click to upload or drag & drop images</p>
                <p style="font-size: 12px; color: #94a3b8; margin-top: 5px;">Supports JPG, PNG</p>
                <input type="file" id="fileInput" accept="image/*" multiple>
            </div>
            
            <div class="image-list" id="imageList"></div>
            
            <div class="navigation">
                <button class="btn btn-secondary" id="clearBtn">Clear All</button>
                <button class="btn" id="nextBtn" disabled>Next</button>
            </div>
        </div>
        
        <!-- Processing Section -->
        <div class="processing-section" id="processingSection">
            <div class="processing-header">
                <div class="processing-title">Processing Images</div>
                <div class="processing-stats" id="processingStats">0/0 completed</div>
            </div>
            
            <div class="image-list" id="processingList"></div>
            
            <div class="navigation">
                <button class="btn btn-secondary" id="backBtn">Back</button>
                <button class="btn" id="downloadAllBtn" disabled>Download All</button>
            </div>
        </div>
    </div>
    
    <!-- Copyright -->
    <div class="copyright">
        © <a href="https://github.com/cziter15" target="_blank" rel="noopener noreferrer">K. STREHLAU</a>
    </div>

    <script>
        // Define constants for model URLs
        const MODEL_URL = 'model.onnx';
        const MODEL_DATA_URL = 'model.onnx.data';
        
        // Debug logging function
        function debugLog(message) {
            console.log(message);
            const debugLog = document.getElementById('debugLog');
            if (debugLog) {
                debugLog.textContent += message + '\n';
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        }
        
        // Check for WebGPU support
        async function checkWebGPUSupport() {
            const result = {
                supported: false,
                error: null,
                details: {}
            };
            try {
                if (!navigator.gpu) {
                    result.error = 'navigator.gpu not found - WebGPU is not supported in this browser';
                    return result;
                }
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    result.error = 'No GPU adapter found - your graphics card may not support WebGPU';
                    return result;
                }
                if (typeof adapter.requestAdapterInfo === 'function') {
                    try {
                        const adapterInfo = await adapter.requestAdapterInfo();
                        result.details.adapter = adapterInfo;
                    } catch (e) {
                        console.log('Adapter info not available:', e);
                    }
                }
                const device = await adapter.requestDevice();
                if (!device) {
                    result.error = 'Failed to create GPU device - your graphics drivers may be outdated';
                    return result;
                }
                result.supported = true;
                return result;
            } catch (e) {
                result.error = `WebGPU error: ${e.message}`;
                return result;
            }
        }
        
        // Update execution provider status
        async function updateExecutionProviderStatus() {
            const providerStatus = document.getElementById('providerStatus');
            const webgpuResult = await checkWebGPUSupport();
            const webglSupported = !!document.createElement('canvas').getContext('webgl') || !!document.createElement('canvas').getContext('experimental-webgl');
            let statusHTML = 'Available execution providers: ';
            if (webgpuResult.supported) {
                statusHTML += '<span class="provider-badge webgpu">WebGPU (Recommended)</span> ';
            }
            if (webglSupported) {
                statusHTML += '<span class="provider-badge wasm">WASM</span> ';
            }
            statusHTML += '<span class="provider-badge cpu">CPU</span>';
            if (webgpuResult.supported) {
                statusHTML += '<p style="margin-top: 8px; color: #4ade80; font-weight: bold;">✓ WebGPU is available - this will provide the best performance!</p>';
                if (webgpuResult.details.adapter) {
                    const adapter = webgpuResult.details.adapter;
                    let gpuInfo = '';
                    if (adapter.vendor) gpuInfo += `Vendor: ${adapter.vendor} `;
                    if (adapter.device) gpuInfo += `Device: ${adapter.device} `;
                    if (adapter.description) gpuInfo += `Description: ${adapter.description}`;
                    if (gpuInfo) {
                        statusHTML += `<p style="font-size: 12px; color: #cbd5e1;">GPU: ${gpuInfo}</p>`;
                    }
                }
            } else {
                statusHTML += '<p style="margin-top: 8px; color: #fbbf24; font-weight: bold;">⚠ WebGPU not available - falling back to WASM/CPU</p>';
                if (webgpuResult.error) {
                    statusHTML += `<p style="font-size: 12px; color: #f87171;">Reason: ${webgpuResult.error}</p>`;
                }
            }
            providerStatus.innerHTML = statusHTML;
        }
        
        class ONNXWatermarkRemover {
            constructor() {
                this.session = null;
                this.modelLoaded = false;
                this.inputSize = 256;
                this.tileSize = 256;
                this.overlap = 32;
                this.modelPath = MODEL_URL;
                this.modelDataPath = MODEL_DATA_URL;
                this.executionProvider = null;
            }
            
            async loadModel(modelPath, modelDataPath) {
                try {
                    debugLog("Loading model...");
                    const modelResponse = await fetch(modelPath);
                    if (!modelResponse.ok) {
                        throw new Error(`Failed to fetch model: ${modelResponse.statusText}`);
                    }
                    const modelBuffer = await modelResponse.arrayBuffer();
                    debugLog(`Model loaded, size: ${modelBuffer.byteLength} bytes`);
                    let externalDataBuffer = null;
                    let externalDataLoaded = false;
                    try {
                        const dataResponse = await fetch(modelDataPath);
                        if (dataResponse.ok) {
                            externalDataBuffer = await dataResponse.arrayBuffer();
                            externalDataLoaded = true;
                            debugLog("External data file loaded successfully");
                        } else {
                            debugLog(`External data file not found: ${dataResponse.statusText}`);
                        }
                    } catch (e) {
                        debugLog(`External data file not found (optional): ${e.message}`);
                    }
                    const sessionOptions = {
                        executionProviders: ['webgpu', 'wasm', 'cpu']
                    };
                    if (externalDataLoaded && externalDataBuffer) {
                        sessionOptions.externalData = [{
                            data: externalDataBuffer,
                            path: 'model.onnx.data'
                        }];
                    }
                    debugLog("Creating inference session...");
                    const session = await ort.InferenceSession.create(modelBuffer, sessionOptions);
                    const inputNames = session.inputNames;
                    const outputNames = session.outputNames;
                    debugLog(`Model inputs: ${JSON.stringify(inputNames)}`);
                    debugLog(`Model outputs: ${JSON.stringify(outputNames)}`);
                    if (session.handler) {
                        this.executionProvider = session.handler.backendName || 'unknown';
                    } else {
                        this.executionProvider = 'unknown';
                    }
                    debugLog(`Using execution provider: ${this.executionProvider}`);
                    this.session = session;
                    this.modelLoaded = true;
                    this.modelPath = modelPath;
                    this.modelDataPath = modelDataPath;
                    return true;
                } catch (error) {
                    debugLog(`Model loading error: ${error.message}`);
                    console.error('Model loading error:', error);
                    return false;
                }
            }
            
            async processImage(image, progressCallback) {
                if (!this.modelLoaded) {
                    throw new Error('Model not loaded');
                }
                const originalWidth = image.width;
                const originalHeight = image.height;
                debugLog(`Processing image: ${originalWidth}x${originalHeight}`);
                if (originalWidth < 64 || originalHeight < 64) {
                    throw new Error('Image is too small. Minimum size is 64x64 pixels.');
                }
                return await this.processTiled(image, progressCallback);
            }
            
            async processTiled(image, progressCallback) {
                const originalWidth = image.width;
                const originalHeight = image.height;
                const outputCanvas = document.createElement('canvas');
                outputCanvas.width = originalWidth;
                outputCanvas.height = originalHeight;
                const outputCtx = outputCanvas.getContext('2d', {
                    willReadFrequently: true
                });
                outputCtx.fillStyle = 'black';
                outputCtx.fillRect(0, 0, originalWidth, originalHeight);
                const step = this.tileSize - this.overlap;
                const tiles = [];
                for (let y = 0; y < originalHeight; y += step) {
                    for (let x = 0; x < originalWidth; x += step) {
                        const tileWidth = Math.min(this.tileSize, originalWidth - x);
                        const tileHeight = Math.min(this.tileSize, originalHeight - y);
                        tiles.push({
                            x,
                            y,
                            width: tileWidth,
                            height: tileHeight
                        });
                    }
                }
                debugLog(`Processing ${tiles.length} tiles (size=${this.tileSize}, overlap=${this.overlap})`);
                
                // Create a canvas to draw the tile grid
                const tileGridCanvas = document.createElement('canvas');
                tileGridCanvas.width = originalWidth;
                tileGridCanvas.height = originalHeight;
                const tileGridCtx = tileGridCanvas.getContext('2d');
                
                // Draw the original image
                tileGridCtx.drawImage(image, 0, 0);
                
                // Draw tile grid
                tileGridCtx.strokeStyle = '#60a5fa';
                tileGridCtx.lineWidth = 1;
                for (const tile of tiles) {
                    tileGridCtx.strokeRect(tile.x, tile.y, tile.width, tile.height);
                }
                
                // Add debug header
                const debugElement = document.getElementById('debugLog');
                if (debugElement) {
                    const imageHeader = document.createElement('div');
                    imageHeader.className = 'debug-image-header';
                    imageHeader.innerHTML = `
                        <div class="debug-image-title">Image Processing: ${originalWidth}x${originalHeight}</div>
                        <div class="debug-image-info">
                            <div class="debug-info-item"><strong>Tile Size:</strong> ${this.tileSize}px</div>
                            <div class="debug-info-item"><strong>Overlap:</strong> ${this.overlap}px</div>
                            <div class="debug-info-item"><strong>Total Tiles:</strong> ${tiles.length}</div>
                            <div class="debug-info-item"><strong>Model Input:</strong> ${this.inputSize}px</div>
                            <div class="debug-info-item"><strong>Provider:</strong> ${this.executionProvider.toUpperCase()}</div>
                        </div>
                    `;
                    debugElement.appendChild(imageHeader);
                    
                    // Create tiles grid container
                    const tilesGrid = document.createElement('div');
                    tilesGrid.className = 'debug-tiles-grid';
                    debugElement.appendChild(tilesGrid);
                }
                
                // Process each tile
                for (let i = 0; i < tiles.length; i++) {
                    const tile = tiles[i];
                    await new Promise(resolve => setTimeout(resolve, 5));
                    try {
                        const processedTile = await this.processTile(image, tile, i);
                        this.blendTile(outputCtx, processedTile, tile, originalWidth, originalHeight);
                    } catch (error) {
                        debugLog(`Error processing tile: ${error.message}`);
                    }
                    const progress = Math.round(((i + 1) / tiles.length) * 100);
                    if (progressCallback) {
                        progressCallback(progress, `Processing tile ${i + 1}/${tiles.length} (${this.executionProvider.toUpperCase()})...`);
                    }
                }
                
                return outputCanvas;
            }
            
            async processTile(sourceImage, tile, index) {
                // Extract tile region
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = tile.width;
                tileCanvas.height = tile.height;
                const tileCtx = tileCanvas.getContext('2d');
                tileCtx.drawImage(sourceImage, tile.x, tile.y, tile.width, tile.height, 
                                0, 0, tile.width, tile.height);

                const beforeBase64 = tileCanvas.toDataURL('image/png');
                const tileName = `Tile (${tile.x}, ${tile.y})`;

                // Resize to model input size (256x256)
                const inputCanvas = document.createElement('canvas');
                inputCanvas.width = this.inputSize;
                inputCanvas.height = this.inputSize;
                const inputCtx = inputCanvas.getContext('2d');
                
                inputCtx.imageSmoothingEnabled = true;
                inputCtx.imageSmoothingQuality = 'high';
                inputCtx.drawImage(tileCanvas, 0, 0, tile.width, tile.height, 
                                0, 0, this.inputSize, this.inputSize);

                const imageData = inputCtx.getImageData(0, 0, this.inputSize, this.inputSize);
                const inputTensor = this.imageDataToTensor(imageData);

                // Run inference
                const feeds = {};
                feeds[this.session.inputNames[0]] = inputTensor;
                const results = await this.session.run(feeds);

                const outputTensor = results[this.session.outputNames[0]];
                const outputImageData = this.tensorToImageData(outputTensor);

                // Create output canvas at model size
                const outputModelCanvas = document.createElement('canvas');
                outputModelCanvas.width = this.inputSize;
                outputModelCanvas.height = this.inputSize;
                const outputModelCtx = outputModelCanvas.getContext('2d');
                outputModelCtx.putImageData(outputImageData, 0, 0);

                // Resize back to original tile size
                const outputTileCanvas = document.createElement('canvas');
                outputTileCanvas.width = tile.width;
                outputTileCanvas.height = tile.height;
                const outputTileCtx = outputTileCanvas.getContext('2d');
                
                outputTileCtx.imageSmoothingEnabled = true;
                outputTileCtx.imageSmoothingQuality = 'high';
                outputTileCtx.drawImage(outputModelCanvas, 0, 0, this.inputSize, this.inputSize,
                                    0, 0, tile.width, tile.height);

                const afterBase64 = outputTileCanvas.toDataURL('image/png');

                // Display images in debug panel
                const tilesGrid = document.querySelector('.debug-tiles-grid');
                if (tilesGrid) {
                    const tileDebug = document.createElement('div');
                    tileDebug.className = 'debug-tile';
                    
                    // Get tensor shapes for display
                    const inputShape = JSON.stringify(inputTensor.dims);
                    const outputShape = JSON.stringify(outputTensor.dims);
                    
                    tileDebug.innerHTML = `
                        <div class="debug-tile-header">${tileName}</div>
                        <div class="debug-tile-content">
                            <div class="debug-image-container debug-image-before">
                                <div class="debug-image-label">BEFORE</div>
                                <img class="debug-image" src="${beforeBase64}" onclick="window.open('${beforeBase64}', '_blank')">
                            </div>
                            <div class="debug-image-container debug-image-after">
                                <div class="debug-image-label">AFTER</div>
                                <img class="debug-image" src="${afterBase64}" onclick="window.open('${afterBase64}', '_blank')">
                            </div>
                        </div>
                        <div class="debug-tile-info">
                            <div><strong>Size:</strong> ${tile.width}x${tile.height}</div>
                            <div><strong>Input:</strong> ${inputShape}</div>
                            <div><strong>Output:</strong> ${outputShape}</div>
                        </div>
                    `;
                    tilesGrid.appendChild(tileDebug);
                    tilesGrid.scrollTop = tilesGrid.scrollHeight;
                }

                return outputTileCanvas;
            }
            
            blendTile(outputCtx, tileCanvas, tile, canvasWidth, canvasHeight) {
                const tileCtx = tileCanvas.getContext('2d', {
                    willReadFrequently: true
                });
                const tileImageData = tileCtx.getImageData(0, 0, tile.width, tile.height);
                const tileData = tileImageData.data;
                const outputImageData = outputCtx.getImageData(tile.x, tile.y, tile.width, tile.height);
                const outputData = outputImageData.data;
                for (let ty = 0; ty < tile.height; ty++) {
                    for (let tx = 0; tx < tile.width; tx++) {
                        const pixelIdx = (ty * tile.width + tx) * 4;
                        let blendFactor = 1.0;
                        if (tile.x > 0 && tx < this.overlap) {
                            blendFactor *= tx / this.overlap;
                        }
                        if (tile.y > 0 && ty < this.overlap) {
                            blendFactor *= ty / this.overlap;
                        }
                        if (tile.x + tile.width < canvasWidth && tx >= tile.width - this.overlap) {
                            blendFactor *= (tile.width - tx) / this.overlap;
                        }
                        if (tile.y + tile.height < canvasHeight && ty >= tile.height - this.overlap) {
                            blendFactor *= (tile.height - ty) / this.overlap;
                        }
                        const r = Math.round(outputData[pixelIdx] * (1 - blendFactor) + tileData[pixelIdx] * blendFactor);
                        const g = Math.round(outputData[pixelIdx + 1] * (1 - blendFactor) + tileData[pixelIdx + 1] * blendFactor);
                        const b = Math.round(outputData[pixelIdx + 2] * (1 - blendFactor) + tileData[pixelIdx + 2] * blendFactor);
                        outputData[pixelIdx] = r;
                        outputData[pixelIdx + 1] = g;
                        outputData[pixelIdx + 2] = b;
                        outputData[pixelIdx + 3] = 255;
                    }
                }
                outputCtx.putImageData(outputImageData, tile.x, tile.y);
            }
            
            imageDataToTensor(imageData) {
                const { width, height, data } = imageData;
                // 3 channels only: RGB (no alpha)
                const tensorData = new Float32Array(3 * width * height);

                // Convert RGBA to RGB, normalize to [0, 1]
                // Format: [1, 3, H, W]
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const pixelIndex = i * width + j;
                        const dataIndex = pixelIndex * 4; // RGBA has 4 values per pixel

                        // Extract RGB only (skip alpha at dataIndex + 3)
                        tensorData[pixelIndex] = data[dataIndex] / 255.0;                    // R
                        tensorData[width * height + pixelIndex] = data[dataIndex + 1] / 255.0; // G
                        tensorData[width * height * 2 + pixelIndex] = data[dataIndex + 2] / 255.0; // B
                    }
                }

                debugLog(`Input tensor: [1, 3, ${height}, ${width}]`);
                return new ort.Tensor('float32', tensorData, [1, 3, height, width]);
            }

            tensorToImageData(tensor) {
                const dims = tensor.dims;
                
                if (dims.length !== 4) {
                    throw new Error(`Expected 4D tensor, got ${dims.length}D: [${dims.join(', ')}]`);
                }
                
                const [batch, channels, height, width] = dims;
                
                debugLog(`Output tensor: [${batch}, ${channels}, ${height}, ${width}]`);
                
                if (batch !== 1 || channels !== 3) {
                    throw new Error(`Unexpected tensor shape: [${batch}, ${channels}, ${height}, ${width}]. Expected [1, 3, H, W]`);
                }
                
                const data = tensor.data;
                // Create RGBA image data for canvas
                const imageData = new ImageData(width, height);
                const pixelData = imageData.data;

                // Convert [1, 3, H, W] to RGBA (add alpha channel)
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const pixelIndex = i * width + j;
                        const dataIndex = pixelIndex * 4; // RGBA has 4 values per pixel

                        // Get RGB values from tensor (3 channels)
                        let r = data[pixelIndex];                              // R channel
                        let g = data[width * height + pixelIndex];             // G channel
                        let b = data[width * height * 2 + pixelIndex];         // B channel

                        // Clamp to [0, 1] range
                        r = Math.max(0, Math.min(1, r));
                        g = Math.max(0, Math.min(1, g));
                        b = Math.max(0, Math.min(1, b));

                        // Convert to [0, 255] and set RGBA
                        pixelData[dataIndex] = Math.round(r * 255);     // R
                        pixelData[dataIndex + 1] = Math.round(g * 255); // G
                        pixelData[dataIndex + 2] = Math.round(b * 255); // B
                        pixelData[dataIndex + 3] = 255;                 // A (always opaque)
                    }
                }

                return imageData;
            }
        }

        // Image management
        class ImageManager {
            constructor() {
                this.images = [];
                this.processedImages = [];
            }
            
            addImage(file) {
                return new Promise((resolve, reject) => {
                    if (!file.type.match('image.*')) {
                        reject(new Error('Please upload an image file (JPEG, PNG, etc.)'));
                        return;
                    }
                    if (file.size > 20 * 1024 * 1024) {
                        reject(new Error('File is too large. Please upload an image smaller than 20MB.'));
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const imageObj = {
                                id: Date.now() + Math.random(),
                                file: file,
                                name: file.name,
                                size: file.size,
                                width: img.width,
                                height: img.height,
                                image: img,
                                dataUrl: e.target.result,
                                status: 'pending'
                            };
                            this.images.push(imageObj);
                            resolve(imageObj);
                        };
                        img.onerror = () => {
                            reject(new Error('Failed to load image. Please try another file.'));
                        };
                        img.src = e.target.result;
                    };
                    reader.onerror = () => {
                        reject(new Error('Failed to read file. Please try again.'));
                    };
                    reader.readAsDataURL(file);
                });
            }
            
            removeImage(id) {
                this.images = this.images.filter(img => img.id !== id);
            }
            
            clearAll() {
                this.images = [];
                this.processedImages = [];
            }
            
            getImages() {
                return this.images;
            }
            
            getProcessedImages() {
                return this.processedImages;
            }
            
            updateImageStatus(id, status) {
                const image = this.images.find(img => img.id === id);
                if (image) {
                    image.status = status;
                }
            }
            
            addProcessedImage(id, canvas) {
                const originalImage = this.images.find(img => img.id === id);
                if (originalImage) {
                    this.processedImages.push({
                        id: id,
                        name: originalImage.name,
                        canvas: canvas,
                        status: 'completed'
                    });
                }
            }
        }
        
        // UI Controller
        class UIController {
            constructor(remover, imageManager) {
                this.remover = remover;
                this.imageManager = imageManager;
                this.initializeElements();
                this.attachEventListeners();
            }
            
            initializeElements() {
                this.loadingScreen = document.getElementById('loadingScreen');
                this.uploadSection = document.getElementById('uploadSection');
                this.processingSection = document.getElementById('processingSection');
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.imageList = document.getElementById('imageList');
                this.processingList = document.getElementById('processingList');
                this.nextBtn = document.getElementById('nextBtn');
                this.backBtn = document.getElementById('backBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.downloadAllBtn = document.getElementById('downloadAllBtn');
                this.tileSizeInput = document.getElementById('tileSize');
                this.overlapInput = document.getElementById('overlap');
                this.inputSizeInput = document.getElementById('inputSize');
                this.processingStats = document.getElementById('processingStats');
                this.debugPanel = document.getElementById('debugPanel');
                this.debugLog = document.getElementById('debugLog');
            }
            
            attachEventListeners() {
                this.uploadArea.addEventListener('click', () => this.fileInput.click());
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.add('drag-over');
                });
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.classList.remove('drag-over');
                });
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.remove('drag-over');
                    this.handleFiles(e.dataTransfer.files);
                });
                this.fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });
                this.nextBtn.addEventListener('click', () => {
                    this.showProcessingSection();
                });
                this.backBtn.addEventListener('click', () => {
                    this.showUploadSection();
                });
                this.clearBtn.addEventListener('click', () => {
                    this.imageManager.clearAll();
                    this.renderImageList();
                    this.updateNextButton();
                    if (this.debugLog) {
                        this.debugLog.innerHTML = '';
                    }
                });
                this.downloadAllBtn.addEventListener('click', () => {
                    this.downloadAllImages();
                });
                this.tileSizeInput.addEventListener('change', () => {
                    const value = parseInt(this.tileSizeInput.value);
                    if (value >= 64 && value <= 1024) {
                        this.remover.tileSize = value;
                    }
                });
                this.overlapInput.addEventListener('change', () => {
                    const value = parseInt(this.overlapInput.value);
                    if (value >= 0 && value <= 64) {
                        this.remover.overlap = value;
                    }
                });
                this.inputSizeInput.addEventListener('change', () => {
                    const value = parseInt(this.inputSizeInput.value);
                    if (value >= 64 && value <= 512) {
                        this.remover.inputSize = value;
                    }
                });
            }
            
            async handleFiles(files) {
                if (this.debugLog) {
                    this.debugLog.innerHTML = '';
                }
                for (let i = 0; i < files.length; i++) {
                    try {
                        const image = await this.imageManager.addImage(files[i]);
                        this.renderImageList();
                        this.updateNextButton();
                    } catch (error) {
                        console.error('Error adding image:', error);
                        alert(error.message);
                    }
                }
            }
            
            renderImageList() {
                const images = this.imageManager.getImages();
                if (images.length === 0) {
                    this.imageList.innerHTML = '';
                    return;
                }
                this.imageList.innerHTML = images.map(image => `
                    <div class="image-item">
                        <div class="image-header">
                            <div class="image-name">${image.name}</div>
                            <div class="image-size">${this.formatFileSize(image.size)}</div>
                            <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="uiController.removeImage(${image.id})">Remove</button>
                        </div>
                        <div class="image-preview">
                            <div class="preview-box">
                                <div class="preview-title">Original</div>
                                <img class="preview-img" src="${image.dataUrl}" alt="Original">
                            </div>
                            <div class="preview-box">
                                <div class="preview-title">Processed</div>
                                <div class="preview-img" style="background-color: var(--background-color); display: flex; align-items: center; justify-content: center;">
                                    <span style="color: var(--text-secondary);">Not processed yet</span>
                                </div>
                            </div>
                        </div>
                        <div class="status ${image.status}">${this.getStatusText(image.status)}</div>
                    </div>
                `).join('');
            }
            
            renderProcessingList() {
                const images = this.imageManager.getImages();
                const processedImages = this.imageManager.getProcessedImages();
                if (images.length === 0) {
                    this.processingList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">📷</div>
                            <p>No images to process</p>
                        </div>
                    `;
                    return;
                }
                this.processingList.innerHTML = images.map(image => {
                    const processedImage = processedImages.find(img => img.id === image.id);
                    let processedImageHtml = '';
                    if (processedImage) {
                        const ctx = processedImage.canvas.getContext('2d');
                        const imageData = ctx.getImageData(0, 0, 1, 1);
                        const hasContent = imageData.data[0] !== 0 || imageData.data[1] !== 0 || imageData.data[2] !== 0;
                        if (hasContent) {
                            processedImageHtml = `<img class="preview-img" src="${processedImage.canvas.toDataURL()}" alt="Processed">`;
                        } else {
                            processedImageHtml = `
                                <div class="preview-img" style="background-color: var(--background-color); display: flex; align-items: center; justify-content: center; flex-direction: column;">
                                    <span style="color: var(--text-secondary);">Processing result</span>
                                </div>
                            `;
                        }
                    } else {
                        processedImageHtml = `
                            <div class="preview-img" style="background-color: var(--background-color); display: flex; align-items: center; justify-content: center;">
                                <span style="color: var(--text-secondary);">Processing...</span>
                            </div>
                        `;
                    }
                    return `
                        <div class="image-item">
                            <div class="image-header">
                                <div class="image-name">${image.name}</div>
                                <div class="image-size">${this.formatFileSize(image.size)}</div>
                            </div>
                            <div class="image-preview">
                                <div class="preview-box">
                                    <div class="preview-title">Original</div>
                                    <img class="preview-img" src="${image.dataUrl}" alt="Original">
                                </div>
                                <div class="preview-box">
                                    <div class="preview-title">Processed</div>
                                    ${processedImageHtml}
                                </div>
                            </div>
                            <div class="progress-container">
                                <div class="progress-bar" id="progress-${image.id}" style="width: ${processedImage ? '100%' : '0%'}"></div>
                            </div>
                            <div class="progress-text">
                                <span id="progress-text-${image.id}">${processedImage ? 'Completed' : 'Waiting to process...'}</span>
                                <span>${processedImage ? '100%' : '0%'}</span>
                            </div>
                            <div class="status ${image.status}">${this.getStatusText(image.status)}</div>
                        </div>
                    `;
                }).join('');
            }
            
            removeImage(id) {
                this.imageManager.removeImage(id);
                this.renderImageList();
                this.updateNextButton();
            }
            
            updateNextButton() {
                this.nextBtn.disabled = this.imageManager.getImages().length === 0;
            }
            
            showUploadSection() {
                this.uploadSection.style.display = 'block';
                this.processingSection.style.display = 'none';
            }
            
            showProcessingSection() {
                this.uploadSection.style.display = 'none';
                this.processingSection.style.display = 'block';
                this.renderProcessingList();
                this.processImages();
            }
            
            async processImages() {
                const images = this.imageManager.getImages();
                let completedCount = 0;
                this.updateProcessingStats(completedCount, images.length);
                for (const image of images) {
                    try {
                        // Clear debug panel for new image
                        if (this.debugLog) {
                            this.debugLog.innerHTML = '';
                        }
                        
                        this.imageManager.updateImageStatus(image.id, 'processing');
                        this.renderProcessingList();
                        const progressBar = document.getElementById(`progress-${image.id}`);
                        const progressText = document.getElementById(`progress-text-${image.id}`);
                        const processedCanvas = await this.remover.processImage(image.image, (percent, message) => {
                            if (progressBar) {
                                progressBar.style.width = `${percent}%`;
                            }
                            if (progressText) {
                                progressText.textContent = message;
                            }
                            const percentElement = progressText.nextElementSibling;
                            if (percentElement) {
                                percentElement.textContent = `${percent}%`;
                            }
                        });
                        this.imageManager.addProcessedImage(image.id, processedCanvas);
                        this.imageManager.updateImageStatus(image.id, 'completed');
                        completedCount++;
                        this.updateProcessingStats(completedCount, images.length);
                        this.renderProcessingList();
                        if (completedCount === images.length) {
                            this.downloadAllBtn.disabled = false;
                        }
                    } catch (error) {
                        console.error('Error processing image:', error);
                        this.imageManager.updateImageStatus(image.id, 'error');
                        this.renderProcessingList();
                        completedCount++;
                        this.updateProcessingStats(completedCount, images.length);
                    }
                }
            }
            
            updateProcessingStats(completed, total) {
                this.processingStats.textContent = `${completed}/${total} completed`;
            }
            
            downloadAllImages() {
                const processedImages = this.imageManager.getProcessedImages();
                if (processedImages.length === 0) {
                    return;
                }
                processedImages.forEach(image => {
                    image.canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        const baseName = image.name.split('.').slice(0, -1).join('.');
                        link.download = `${baseName}_watermark_removed.png`;
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                    }, 'image/png', 1.0);
                });
            }
            
            formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                else if (bytes < 1048576) return Math.round(bytes / 1024) + ' KB';
                else return Math.round(bytes / 1048576 * 10) / 10 + ' MB';
            }
            
            getStatusText(status) {
                switch (status) {
                    case 'pending':
                        return 'Pending';
                    case 'processing':
                        return 'Processing...';
                    case 'completed':
                        return 'Completed';
                    case 'error':
                        return 'Error';
                    default:
                        return status;
                }
            }
        }
        
        // Initialize the application
        let remover, imageManager, uiController;
        async function initialize() {
            await updateExecutionProviderStatus();
            remover = new ONNXWatermarkRemover();
            imageManager = new ImageManager();
            uiController = new UIController(remover, imageManager);
            document.getElementById('debugPanel').style.display = 'block';
            const success = await remover.loadModel(MODEL_URL, MODEL_DATA_URL);
            if (success) {
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('uploadSection').style.display = 'block';
            } else {
                const loadingScreen = document.getElementById('loadingScreen');
                loadingScreen.innerHTML = `
                    <div class="error-message">
                        <h4>Failed to load model</h4>
                        <p>Please check that the model files (model.onnx and model.onnx.data) are in the correct location.</p>
                        <p>Also ensure your browser supports WebAssembly.</p>
                    </div>
                    <button class="btn" onclick="location.reload()">Retry</button>
                `;
            }
        }
        window.addEventListener('load', initialize);
    </script>
</body>
</html>